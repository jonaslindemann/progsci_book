%---------------------------------------------------------------------
%---------------------------------------------------------------------
\chapter{The Fortran Language}
%---------------------------------------------------------------------
%---------------------------------------------------------------------

Fortran was the first high-level language and was developed in the fifties. The languages has since the developed through a number of standards Fortran IV (1966), Fortran 77, Fortran 90, Fortran 95 and the latest Fortran 2003. The advantages with standardised languages is that the code can be run on different computer architectures without modification. In every new standard the language has been extended with more modern language elements. To be compatible with previous standards older language elements are not removed. However, language elements that are considered bad or outdated can be removed after 2 standard revisions. As an example Fortran 90 is fully backwards compatible with Fortran 77, but in Fortran 95 some
older language constructs where removed. 

The following sections gives a short introduction to the Fortran 90 language and some of the extensions in Fortran 95. The description is centered on the most important language features. A more thorough description of the language can be found in the book Fortran 95/2003 Explained \cite{metcalf00}

%---------------------------------------------------------------------
\section{Program structure}
%---------------------------------------------------------------------

Every Fortran-program must have a main program routine. From the main routine, other subroutines that make up the program are called. The syntax for a main program is:

\begin{fsyntax}
[\textbf{program} program-name]\newline%
\indent[specification statements]\newline%
\indent[executable statements]\newline%
\indent[contains]\newline%
\indent[subroutines]\newline%
\textbf{end} [\textbf{program} [program-name]]\newline
\end{fsyntax}

From the syntax it can be seen that the only identifier that must be included in main program definition is \fkeyw{end}.

The syntax for a subroutine and functions are defined in the same way, but the \fkeyw{program} identifier is replaced with \fkeyw{subroutine} or \fkeyw{function}. A proper way of organizing subroutines is to place these in separat files or place the in modules (covered in upcoming sections). Subroutines can also be placed in the main program \fkeyw{contains}-section, which is the preferred method if all subroutines are placed in the same source file. The code below shows a simple example of a main program with a subroutine in Fortran.

\lstinputlisting{source/sample1/sample1.f90}

The program source code can contain upper and lower case letters, numbers and special characters. However, it should be noted that Fortran does not differentiate between upper and lower case letters. The program source is written starting from the first position with one statement on each line. If a row is terminated with the charachter \foper{\&}, this indicates that the statement is continued on the the next line. All text placed after the character \foper{!} is a comment and wont affect the function of the program. Even if the comments don't have any function in the program they are important for source code readability. This is especially important for future modification of the program. In addition to the source code
form described above there is also the possibility of writing code in fixed form, as in Fortran 77 and earlier versions. In previous version of the Fortran standard this was the only source code form available.

%---------------------------------------------------------------------
\section{Variables}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\subsection{Naming of variables}
%---------------------------------------------------------------------

Variables in Fortran 95 consists of 1 to 31 alphanumeric characters (letters except   and , underscore and numbers). The first character of a variable name must be a letter. Allowable variable names can be:

\begin{lstlisting}
a
a_thing
x1
mass
q123
time_of_flight
\end{lstlisting}

Variable names can consist of both upper case and lower case letters. It should be noted that \fvar{a} and \fvar{A} references the same variable. Invalid variables names can be:

\begin{lstlisting}[texcl]
1a      ! First character not a letter
a thing ! Contains a space character
\$sign  ! Contains a non-alphanumeric character
\end{lstlisting}

%---------------------------------------------------------------------
\subsection{Variable types and declarations}
%---------------------------------------------------------------------

There are 5 built-in data types in Fortran:

\begin{xlist}
    \item \ftype{integer}, Integers
    \item \ftype{real}, Floating point numbers
    \item \ftype{complex}, Complex numbers
    \item \ftype{logical}, Boolean values
    \item \ftype{character}, Strings and characters
\end{xlist}

The syntax for a variable declaration is:

\begin{fsyntax}
type [[,attribute]... ::] entity-list
\end{fsyntax}

\fexpr{type} defines the variable type and can be\ftype{integer}, \ftype{real}, \ftype{complex}, \ftype{logical}, \ftype{character}, or \ftype{type}( type-name ). \ftype{attribute} defines additional special attributes or how the variable is to be used. The following examples shows
some typical Fortran variable declarations.

\begin{lstlisting}[texcl]
integer :: a     ! Scalar integer variable
real :: b        ! Scalar floating point variable
logical :: flag  ! boolean variable

real :: D(10)    ! Floating point array consisting of 10 elements
real :: K(20,20) ! Floating point array of 20x20 elements

integer, dimension(10) :: C     ! Integer array of 10 elements

character :: ch                 ! Character
character, dimension(60) :: chv ! Array of characters
character(len=80) :: line       ! Character string
character(len=80) :: lines(60)  ! Array of strings
\end{lstlisting}

Constants are declared by specifying an additional keyword, \fkeyw{parameter}. A declared constant can be used in following variable declarations. An example of use is shown in the following example.

\begin{lstlisting}[texcl]
integer, parameter :: A = 5 ! Integer constant
real :: C(A)                ! Floating point array where
                            ! the number of elements is
                            ! specified by A
\end{lstlisting}

The precision and size of the variable type can be specified by adding a parenthesis directly after the type declaration. The variables \fvar{A} and \fvar{B} in the following example are declared as floating point scalars with different precisions. The number in the parenthesis denotes for many architectures, how many bytes a floating point variable is represented with.

\begin{lstlisting}[texcl]
real(8) :: A
real(4) :: B
integer(4) :: I
\end{lstlisting}

To be able to choose the correct precision for a floating point variable, Fortran has a built in function \fkeyw{selected\_real\_kind} that returns the value to be used in the declaration with a given precision. This is illustrated in the following example.

\begin{lstlisting}
integer, parameter :: ap = selected_real_kind(15,300)
real(kind=ap) :: X,Y
\end{lstlisting}

In this example the floating point variable should have at least 15 significant decimals and could represent numbers from 10$^{-300}$ to 10$^{300}$. For several common architectures \fkeyw{selected\_real\_kind} will return the value 8. The advantage of using the above approach is that the precision of the floating point values can be specified in a architectural independent way. The precision constant can also be used when
specifying numbers in variable assignments as the following example illustrate.

\begin{lstlisting}
X = 6.0_ap
\end{lstlisting}

The importance of specifying the precision for assigning scalar values to variables is illustrated in the following example.

\begin{lstlisting}
program constants

    implicit none

    integer, parameter :: ap = selected_real_kind(15,300)

    real(ap) :: pi1, pi2
    pi1 = 3.141592653589793
    pi2 = 3.141592653589793_ap

    write(*,*) 'pi1 = ', pi1
    write(*,*) 'pi2 = ', pi2

    stop

end program constants
\end{lstlisting}

The program gives the following results:

\cmdmode

\begin{lstlisting}
pi1 = 3.14159274101257
pi2 = 3.14159265358979
\end{lstlisting}

\fmode

The scalar number assigned to the variable \fvar{pi1} is chosen by the compiler to be represented by the least number of bytes floating point precision, in this case \ftype{real(4)}, which is shown in the output from the above program. 

Variable declarations in Fortran always precedes the executable statements in the main program or in a subroutine. Declarations can also be placed directly after the \fkeyw{module} identifier in modules. 

%---------------------------------------------------------------------
\subsection{General type rule}
%---------------------------------------------------------------------

Variable do not have to be declared in Fortran. The default is that variables starting I, J,..., N are defined as \ftype{integer} and variables starting with A, B,... ,H or O, P,... , Z are defined as \ftype{real}. This kind of implicit variable declaration is not recommended as it can lead to programming errors when variables are misspelled. To avoid implicit variable declarations the following declaration can be placed first in a program or module:

\fmode

\begin{lstlisting}
implicit none
\end{lstlisting}

This statement forces the compiler to make sure that all variables are declared. If a variable is not declared the compilation is stopped with an error message. This is default for many other strongly typed languages such as, C, C++ and Java.

%---------------------------------------------------------------------
\subsection{Assignment of variables}
%---------------------------------------------------------------------

The syntax for scalar variable assignment is, 

\begin{fsyntax}
variable = expr
\end{fsyntax}

where \fvar{variable} denotes the variable to be assigned and \fexpr{expr} the expression to be assigned. The following example assign the \fvar{a} variable the value 5.0 with the precision defined in the constant \fkeyw{ap}.

\begin{lstlisting}
a = 5.0_ap
\end{lstlisting}

Assignment of boolean variables are done in the same way using the keywords, \fkeyw{.false.} and \fkeyw{.true.} indicating a true or false value. A boolean expression can also be used int the assignment. In the following example the variable, \fvar{flag}, is assigned the value \fkeyw{.false.}.

\begin{lstlisting}
flag =.false.
\end{lstlisting}

Assignment of strings are illustrated in the following example. 

\begin{lstlisting}
character(40) :: first_name
character(40) :: last_name
character(20) :: company_name1
character(20) :: company_name2

...

first_name = 'Jan'
last_name = "Johansson"
company_name1 = "McDonald's"
company_name2 = 'McDonald''s'
\end{lstlisting}

The first variable, \fvar{first\_name}, is assigned the text ''Jan'', remaining characters in the string will be padded with spaces. A string is assigned using citation marks, '' or apostrophes, '. This can be of help when apostrophes or citation marks is used in strings as shown in the assignemnt of the variables, \fvar{company\_name1} och \fvar{company\_name2}.


%---------------------------------------------------------------------
\subsection{Defined and undefined variables}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\subsection{Derived datatypes}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\subsection{Determining appropriate types}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\section{Operators}
%---------------------------------------------------------------------

The following arithmetic operators are defined in Fortran:

\vspace{5mm}
\begin{tabular}{ll}
  \foper{**} & power to \\
  \foper{*} & multiplication \\
  \foper{/} & division \\
  \foper{+} & addition \\
  \foper{-} & subtraction \\
\end{tabular}
\vspace{5mm}

Parenthesis are used to specify the order of different operators. If no parenthesis are given in an expression operators are evaluated in the following order:

\begin{enumerate}
\item Operations with \foper{**}%
\item Operations with \foper{*} or \foper{/}%
\item Operations with \foper{+} or \foper{--}
\end{enumerate}

\noindent The following code illustrates operator precedence.

\begin{lstlisting}[texcl]
c = a+b/2 ! is equivalent to $a+(b/2)$
c = (a+b)/2 ! in this case $(a+b)$ is evaluated and then $/$ 2
\end{lstlisting}

\noindent Relational operators:

\vspace{5mm}
\begin{tabular}{lp{0.6\textwidth}}
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  \foper{<} or \foper{.lt.} & less than ({\underline {l}}ess {\underline {t}}han) \\
  \foper{<=} or \foper{.le.} & less than or equal to ({\underline {l}}ess than or {\underline {e}}qual) \\
  \foper{>} or \foper{.gt.} & greater than ({\underline{g}}reater {\underline {t}}han)  \\
  \foper{>=} or \foper{.ge.} & greater than or equal to ({\underline {g}}reater than or {\underline {e}}qual) \\
  \foper{==} or \foper{.eq.} & equal to ({\underline {eq}}ual) \\
  \foper{/=} or \foper{.ne.} & not equal to ({\underline {n}}ot {\underline {e}}qual) \\
\end{tabular}
\vspace{5mm}

\noindent Logical operators:

\vspace{5mm}
\begin{tabular}{ll}
\foper{.and.} & and \\
\foper{.or.} & or \\
\foper{.not.} & not \\
\end{tabular}
\vspace{5mm}

%---------------------------------------------------------------------
\subsection{Expressions}
%---------------------------------------------------------------------

Integer expressions.

Mixed mode expressions

Array expressions?


%---------------------------------------------------------------------
\section{Arrays and matrices}
%---------------------------------------------------------------------

In scientific and technical applications matrices and arrays are important concepts. As Fortran is a language mainly for
technical computing, arrays and matrices play a vital role in the language.

Declaring arrays and matrices can be done in two ways. In the first method the dimensions are specified using the special attribute, \fkeyw{dimension}, after the data type declaration. The second method, the dimensions are specified by adding the dimensions directly after the variable name. The following code illustrate these methods of declaring arrays.

\begin{lstlisting}
integer, parameter :: ap = selected_real_kind(15,300)
real(ap),dimension(20,20) :: K ! Matrix 20x20 elements
real(ap) :: fe(6) ! Array with 6 elements
\end{lstlisting}

The default starting index in arrays is 1. It is however possible to define custom indices in the declaration, as the following example shows.

\begin{lstlisting}
real(ap) :: idx(-3:3)
\end{lstlisting}

This declares an array, \fvar{idx} with the indices [-3, -2,
-1, 0, 1, 2, 3], which contains 7 elements.

%---------------------------------------------------------------------
\subsection{Array assignment}
%---------------------------------------------------------------------

Arrays are assigned values either by explicit indices or the entire array in a single statement. The following code assigned the variable, \fvar{K}, the value 5.0 at position row 5 and column 6.

\begin{lstlisting}
K(5,6) = 5.0
\end{lstlisting}

If the assignment had been written as

\begin{lstlisting}
K = 5.0
\end{lstlisting}

the entire array, \fvar{K}, would have been assigned the value 5.0. This is an efficient way of assigning entire arrays
initial values.

Explicit values can be assigned to arrays in a single statement using the following assignment.

\begin{lstlisting}
real(ap) :: v(5) ! Array with 5 elements
v = (/ 1.0, 2.0, 3.0, 4.0, 5.0 /)
\end{lstlisting}

This is equivalent to an assignment using the following statements.

\begin{lstlisting}
v(1) = 1.0
v(2) = 2.0
v(3) = 3.0
v(4) = 4.0
v(5) = 5.0
\end{lstlisting}

The number of elements in the list must be the same as the number of elements in the array variable.

Assignments to specific parts of arrays can be achieved using index-notation. The following example illustrates this concept.

\begin{lstlisting}[texcl]
program index_notation

    implicit none
    real :: A(4,4)
    real :: B(4)
    real :: C(4)

    B = A(2,:) ! Assigns B the values of row 2 in A
    C = A(:,1) ! Assigns C the values of column 1 in A

    stop

end program index_notation
\end{lstlisting}

Using index-notation rows or columns can be assigned in single statements as shown in the following code:

\begin{lstlisting}[texcl]
! Assign row 5 in matrix K the values 1, 2, 3, 4, 5

K(5,:) = (/ 1.0, 2.0, 3.0, 4.0, 5.0 /)

! Assign the array v the values 5, 4, 3, 2, 1

v = (/ 5.0, 4.0, 3.0, 2.0, 1.0 /)
\end{lstlisting}


%---------------------------------------------------------------------
\subsection{Array storage}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\subsection{Allocatable arrays}
%---------------------------------------------------------------------

In Fortran 77 and earlier versions of the standard it was not possible to dynamically allocate memory during program execution. This capability is now available in Fortran 90 and later versions. To declare an array as dynamically allocatable, the attribute \fkeyw{allocatable} must be added to the array declaration. The dimensions are also replaced with a colon, :, indicating the number of dimensions in the declared variable. A typical allocatable array declaration is shown in the following example.

\begin{lstlisting}
real, dimension(:,:), allocatable :: K
\end{lstlisting}

In this example the two-dimensional array, K, is defined as allocatable. To indicate that the array is two-dimensional is done by specifying \fkeyw{dimension(:,:)} in the variable attribute. To declare a one-dimensional array the code becomes:

\begin{lstlisting}
real, dimension(:), allocatable :: f
\end{lstlisting}

Variables with the \fkeyw{allocatable} attribute can't be used until memory is allocated. Memory allocation is done using the \fkeyw{allocate} method. To allocate the variables, \fvar{K,f}, in the previous examples the following code is used.

\begin{lstlisting}
allocate(K(20,20))
allocate(f(20))
\end{lstlisting}

When the allocated memory is no longer needed it can be deallocated using the command, \fkeyw{deallocate}, as the following code illustrates.

\begin{lstlisting}
deallocate(K)
deallocate(f)
\end{lstlisting}

An important issue when using dynamically allocatable variable is to make sure the application does not ''leak''. ''Leaking'' is term used by applications that allocate memory during the execution and never deallocate used memory. If unchecked the application will use more and more resources and will eventually make the operating system start swapping and perhaps become also become unstable. A rule of thumb is that an
\fkeyw{allocate} statement should always have corresponding \fkeyw{deallocate}. An example of using dynamically allocated arrays is shown in section XXX.

%---------------------------------------------------------------------
\subsection{Array subobjects}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\section{Conditional statements}
%---------------------------------------------------------------------

The simplest form of if-statements in Fortran have the following syntax

\begin{fsyntax}
\textbf{if} (scalar-logical-expr) \textbf{then}\\
\ftab  block\\
\textbf{end if}\\
\end{fsyntax}

where \fexpr{scalar-logical-expr} is a boolean expression, that has to be evaluated as true, (\fkeyw{.true.}), for the statements in, \fexpr{block}, to be executed. An extended version of the if-statement adds a \fkeyw{else}-block with the following syntax

\begin{fsyntax}
\textbf{if} (scalar-logical-expr) \textbf{then}\\
\ftab block1\\
\textbf{else}\\
\ftab block2\\
\textbf{end if}\\
\end{fsyntax}

In this form the \fexpr{block1} will be executed if \fexpr{scalar-logical-expr} is evaluated as true, otherwise \fexpr{block2} will be executed. A third form of if-statement contains one or more \fkeyw{else if}-statements with the following syntax:

\begin{fsyntax}
\textbf{if} (scalar-logical-expr1) \textbf{then}\\
\ftab block1\\
\textbf{else if} (scalar-logical-expr2) \textbf{then}\\
\ftab block2\\
\textbf{else}\\
\ftab block3\\
\textbf{end if}
\end{fsyntax}

In this form the \fexpr{scalar-logical-expr1} is evaluated first. If this expression is true \fexpr{block1} is executed, otherwise if \fexpr{scalar-logical-expr2} evaluates as true \fexpr{block2} is executed. If no other expressions are evaluated to true, \fexpr{block3} is executed. An if-statement can contain several \fkeyw{else if}-blocks. The use of if-statements is illustrated in the following example:

\lstinputlisting[texcl,escapechar=\%]{source/logic/logic.f90}

Another conditional constructi is the case-statement.

\begin{fsyntax}
\textbf{select case} (expr)\\
\ftab\textbf{case} selector \\
\ftab\ftab block  \\
\textbf{end select}
\end{fsyntax}

In this statement the expression, \fexpr{expr} is evaluated and the \fkeyw{case}-block with the corresponding \fexpr{selector} is executed. To handle the case when no \fkeyw{case}-block corresponds to the \fexpr{expr}, a \fkeyw{case}-block with the \fkeyw{default} keyword can be added. The syntax then becomes:

\begin{fsyntax}
\textbf{select case}(expr)\\
\ftab\textbf{case} selector\\
\ftab\ftab block \\
\ftab\textbf{case default}\\
\ftab\ftab block \\
\textbf{end select}
\end{fsyntax}

Example of case-statement use is shown in the following example:

\begin{lstlisting}
select case (display_mode)
    case (displacements)
        ...
    case (geometry)
        ...
end select
\end{lstlisting}

To handle the case when \fvar{display\_mode} does not correspone to any of the alternatives the above code is modified to the following code.

\begin{lstlisting}
select case (display_mode) case (displacements)
        ...
    case (geometry)
        ...
    case default
        ...
end select
\end{lstlisting}

The following program example illustrate how case-statements can be used.

\lstinputlisting[texcl]{source/case/case.f90}

%---------------------------------------------------------------------
\section{Repetitive statements}
%---------------------------------------------------------------------

The most common repetitive statement in Fortran is the \fkeyw{do}-statement. The syntax is:

\begin{fsyntax}
\textbf{do} variable = expr1, expr2 [,expr3]\\
\ftab block\\
\textbf{end do}
\end{fsyntax}

\fexpr{variable} is the control-variable of the loop. \fexpr{expr1} is the starting value, \fexpr{expr2} is the end value and \fexpr{expr3} is the step interval. If the step interval is not given it is assumed to be 1. There are two ways of controlling the execution flow in a \fkeyw{do}-statement. The \fkeyw{exit} command terminates the loop and program execution is continued after the \fkeyw{do}-statement. The \fkeyw{cycle} command terminates the execution of the current block and continues execution with the next value of the control variable. The example below illustrates the use of a \fkeyw{do}-statement.

\begin{lstlisting}[texcl]
program loop_sample

    implicit none

    integer :: i

    do i=1,20
        if (i>10) then
            write(*,*) 'Terminates do-statement.'
            exit
        else if (i<5) then
            write(*,*) 'Cycling to next value.'
            cycle
        end if
        write(*,*) i
    end do

    stop

end program loop_sample
\end{lstlisting}

The above program gives the following output:

\cmdmode

\begin{lstlisting}[texcl]
Cycling to next value.
Cycling to next value.
Cycling to next value.
Cycling to next value.
5
6
7
8
9
10
Terminates do-statement.
\end{lstlisting}

\fmode

Another repetitive statement available is the \fkeyw{do while}-statement. With this statement, the code block can execute until a certain condition is fulfilled. The syntax is:

\begin{fsyntax}
\textbf{do while} (scalar-logical-expr)\\
\ftab block\\
\textbf{end do}
\end{fsyntax}

The following code shows a simple \fkeyw{do while}-statement printing the function $f(x)=sin(x)$.

\begin{lstlisting}
x = 0.0
do while x<1.05
    f = sin(x)
    x = x + 0.1
    write(*,*) x, f
end do
\end{lstlisting}

There are other repetitive statements such as \fkeyw{forall} and \fkeyw{where} covered int the array features sections.

%---------------------------------------------------------------------
\section{Built-in functions}
%---------------------------------------------------------------------

Fortran has a number of built-in functions covering a number of different areas. The following tables list a selection of these. For a more thorough description of the built-in function please see, Metcalf and Reid \cite{metcalf00}.

\begin{table}[!hb]
\begin{center}
\begin{tabular}{|l|l|}
\hline Function & Description \\ \hline
\lstinline!acos(x)! & Returns $\arccos(x)$ \\
\lstinline!asin(x)! & Returns $\arcsin(x)$ \\
\lstinline!atan(x)! & Returns $\arctan(x)$ \\
\lstinline!atan2(y,x)! & Returns $\arctan(\frac{y}{x})$ from $-\pi$ till $-\pi$ \\
\lstinline!cos(x)!  & Returns $\cos(x)$ \\
\lstinline!cosh(x)! & Returns $\cosh(x)$ \\
\lstinline!exp(x)!  & Returns $e^{x}$ \\
\lstinline!log(x)!  & Returns $\ln(x)$ \\
\lstinline!log10(x)! & Returns $\lg(x)$ \\
\lstinline!sin(x)! & Returns $\sin(x)$ \\
\lstinline!sinh(x)! & Returns $\sinh(x)$ \\
\lstinline!sqrt(x)! & Returns $\sqrt{x}$\\
\lstinline!tan(x)! & Returns $\tan(x)$ \\
\lstinline!tanh(x)! & Returns $\tanh(x)$ \\ \hline
\end{tabular}
\end{center}
\caption{Mathematical functions}
\end{table}

\begin{table}[!hb]
\begin{center}
\begin{tabular}{|l|l|}
\hline Function & Description \\ \hline
\lstinline!abs(a)!  & Returns absolute value of a \\
\lstinline!aint(a)! & Truncates a floating point value \\
\lstinline!int(a)!  & Converts a floating point value to an integer \\
\lstinline!nint(a)! & Rounds a floating point value to the nearest integer \\
\lstinline!real(a)! & Converts an integer to a floating point value \\
\lstinline!max(a1,a2[,a3,...])! & Returns the maximum value of two or more values \\
\lstinline!min(a1,a2[,a3,...])! & Returns the minimum value of two or more values \\
\hline
\end{tabular}
\end{center}
\caption{Miscellaneous conversion functions}
\end{table}

\begin{table}[!hb]
\begin{center}
\begin{tabular}{|l|p{70mm}|}
\hline
Function & Description \\
\hline
\lstinline!dot_product(u, v)! & Returns the scalar product of $u\cdot v$  \\
 & \\
\lstinline!matmul(A, B)! &  Matrix multiplication. The result must have the same for as $\mathbf{AB}$ \\
 & \\
\lstinline!transpose(C)! & Returns the transpose $\mathbf{C}^{T}$. Elementet $C^{T}_{ij}$ motsvarar $C_{ji}$ \\
\hline
\end{tabular}
\end{center}
\caption{Vector and matrix functions}
\end{table}

\begin{table}[!hb]
\begin{center}
\begin{tabular}{|l|p{75mm}|}
\hline
Function & Description \\
\hline
\lstinline!all(mask)! &  Returns true of all elements in the logical array \fexpr{mask} are true. For example \lstinline!all(A>0)! returns true if all elements
in $\mathbf{A}$ are greater than 0. \\
 & \\
\lstinline!any(mask)! &  Returns true if any of the elements in \fexpr{mask} are true. \\
 & \\
\lstinline!count(mask)! & Returns the number of elements in \fexpr{mask} that are true. \\
 & \\
\lstinline!maxval(array)! &   Returns the maximum value of the elements in the array \fexpr{array}. \\
 & \\
\lstinline!minval(array)! &   Returns the minimum value of the elements in the array \fexpr{array}. \\
 & \\
\lstinline!product(array)! &  Returns the product of the elements in the array \fexpr{array}. \\
 & \\
\lstinline!sum(array)! &  Returns the sum of elements in the array \fexpr{array}. \\
\hline
\end{tabular}
\end{center}
\caption{Array functions}
\end{table}

Most built-in functions and operators in Fortran support arrays. The following example shows how functions and operators support operations on arrays.

\begin{lstlisting}[texcl]
real, dimension(20,20) :: A, B, C

C = A/B ! Division $C_{ij}=A_{ij}/B_{ij}$

C = sqrt(A) ! Square root $C_{ij}=\sqrt{A_{ij}}$
\end{lstlisting}

The following example shows how a stiffness matrix for a bar element easily can be created using these functions and operators. The Matrix $\mathbf{K}_{e}$ is defined as follows

\begin{equation}
\mathbf{K}_{e} =(\mathbf{G}^{T} \mathbf{K}_{el} )\mathbf{G}
\end{equation}

The $G^T$ is returned by using the Fortran function \fkeyw{transpose} and the matrix multiplications are performed with \fkeyw{matmul}. The matrices $\mathbf{K}_{el}$ and $\mathbf{G}$ are defined as

\begin{equation}
\mathbf{K}_{el} =\frac{EA}{L} \left[
\begin{array}{cc}
1 & -1 \\
-1 & 1 \\
\end{array}
\right]
\end{equation}

and

\begin{equation}
\mathbf{G}=\left[
\begin{array}{cccccc}
n_{x}  & n_{y}  & n_{z}  & 0 & 0 & 0 \\
0 & 0 & 0 & n_{x} & n_{y} & n_{z} \\
\end{array}
\right]
\end{equation}

Length and directional cosines are defined as

\begin{equation}
L=\sqrt{(x_{2} -x_{1} )^{2} +(y_{2} -y_{1} )^{2} +(z_{2} -z_{1}
)^{2}}
\end{equation}

\begin{equation}
n_{x} =\frac{x_{2} -x_{1} }{L} ,\,\,\,n_{y} =\frac{y_{2} -y_{1}
}{L} ,\,\,\,n_{z} =\frac{z_{2} -z_{1} }{L}
\end{equation}

In the example the input parameters are assigned the following values:

\begin{eqnarray}
x_{1} =0,\,y_{1} =0,\,z_{1} =0 \\
x_{2} =1,\,y_{2} =1,\,z_{2} =1 \\
E\/=\/1,\,\,A=1
\end{eqnarray}

\lstinputlisting[texcl,escapechar=\%]{source/functions/functions.f90}

The program produces the following output

\cmdmode

\begin{lstlisting}[numbers=none,breaklines=false]
0.1925    0.1925    0.1925    -.1925    -.1925    -.1925
0.1925    0.1925    0.1925    -.1925    -.1925    -.1925
0.1925    0.1925    0.1925    -.1925    -.1925    -.1925
-.1925    -.1925    -.1925    0.1925    0.1925    0.1925
-.1925    -.1925    -.1925    0.1925    0.1925    0.1925
-.1925    -.1925    -.1925    0.1925    0.1925    0.1925
\end{lstlisting}

\fmode

For a more thorough description of matrix handling in Fortran 90/95, see Metcalf and Reid \cite{metcalf00}

\subsection{Elemental procedures}
\subsection{Vector and matrix functions}
\subsection{Reduction routines}
\subsection{Information functions}

%---------------------------------------------------------------------
\section{Program units and subroutines}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\subsection{Subprograms}
%---------------------------------------------------------------------

A subroutine in Fortran 90/95 has the following syntax

\begin{fsyntax}
\textbf{subroutine} subroutine-name[([dummy-argument-list])]\\
\ftab [argument-declaration]\\
\ftab ...\\
\ftab \textbf{return}\\
\textbf{end subroutine} [subroutine-name]
\end{fsyntax}

All variables in Fortran program are passed to subroutines as references to the actual variables. Modifying a parameter in a subroutine will modify the values of variables in the calling subroutine or program. To be able to use the variables in the argument list they must be declared in the subroutine. This is done right after the subroutine declaration. When a subroutine is finished control is returned to the calling routine or program using the \fkeyw{return}-command. Several return statements can exist in subroutine to return control to the calling routine or program. This is illustrated in the following example.

\begin{lstlisting}
subroutine myproc(a,B,C)
    implicit none
    integer :: a
    real, dimension(a,*) :: B
    real, dimension(a) :: C
    .
    .
    .
    return
end subroutine
\end{lstlisting}

A subroutine is called using the \fkeyw{call} statement. The above subroutine is called with the following code.

\begin{lstlisting}
call myproc(a,B,C)
\end{lstlisting}

It should be noted that the names used for variables are local to each respective subroutine. Names of variables passed as arguments does not need to have the same name in the calling and called subroutines. It is the order of the arguments that determines how the variables are referenced from the calling subroutine.

In the previous example illustrates how to make the subroutines independent of problem size. The dimensions of the arrays are passed using the \fvar{a} parameter instead of using constant values. The last index of an array does not have to specified, indicated with a *, as it is not needed to determine the address to array element.

%---------------------------------------------------------------------
\subsection{Functions}
%---------------------------------------------------------------------

Functions are subroutines with a return value, and can be used in different kinds of expressions. The syntax is

\begin{fsyntax}
type \textbf{function} function-name([dummy-argument-list])\\
\ftab [argument-declaration]\\
\ftab ...\\
\ftab function-name = return-value\\
\ftab ...\\
\ftab \textbf{return}\\
\textbf{end function} function-name
\end{fsyntax}

The following code shows a simple function definition returning the value of $sin(x)$

\begin{lstlisting}
real function f(x)
    real :: x
    f=sin(x)
    return
end function f
\end{lstlisting}

The return value defined by assigning the name of the function a value. As seen in the previous example. The function is called by giving the name of the function and the associated function arguments.

\begin{lstlisting}
a = f(y)
\end{lstlisting}

The following example illustrates how to use subroutines to assign an element matrix for a three-dimensional bar element. The example also shows how dynamic memory allocation can be used to allocate matrices. See also the example in section XX

\lstinputlisting[texcl]{source/subroutines/subroutines.f90}

The program gives the following output.

\begin{lstlisting}[numbers=none,breaklines=false]
0.1925    0.1925    0.1925    -.1925    -.1925    -.1925
0.1925    0.1925    0.1925    -.1925    -.1925    -.1925
0.1925    0.1925    0.1925    -.1925    -.1925    -.1925
-.1925    -.1925    -.1925    0.1925    0.1925    0.1925
-.1925    -.1925    -.1925    0.1925    0.1925    0.1925
-.1925    -.1925    -.1925    0.1925    0.1925    0.1925
\end{lstlisting}

%---------------------------------------------------------------------
\subsection{Keyword and optional arguments}
%---------------------------------------------------------------------

Sometimes when implementing subroutines the number of arguments can grow, making the usage of the unnecessary complicated. To solve this wrapper subroutines could be written providing default parameters for main subroutines. This has the drawback of additional maintenance of the wrapper subroutines when the main subroutine is changed. Fortran 2003 provides a solution to this using keyword and optional arguments. An additional parameter attribute, \fkeyw{optional}, can be specified when declaring subroutine parameters. In the following example the, \fvar{c} is declared optinal and does not need to be given when the routine is called.

\begin{lstlisting}
subroutine dostuff(A, b, c)

	real(8) :: A(10,10)
	integer :: b
	integer, optional :: c
	...
	
\end{lstlisting}

The \fkeyw{dostuff} routine can be called in 2 ways:

\begin{lstlisting}
call dostuff(A, b)    ! c is omitted as it is optional
call dostuff(A, b, c) 
\end{lstlisting}

If a routine is called without optional parameters the routine has to be able to determine if a parameter used this can be done using a special function, \fkeyw{present(...)}. This functions returns \fkeyw{.true.} if given parameter is present in the call to the subroutine.

In addition of having optional parameters, subroutine parameters can also be specified by parameter name or keyword. In the following example all these techniques are employed when implementing the \fkeyw{order\_icecream} subroutine. This routine only has one required argument, \fkeyw{number}. The other parameters are optional as indicated by the, \fkeyw{optional} in the parameter declaration.

\lstinputlisting{source/optional_arguments/main.f90}

In the last call the \fkeyw{topping} keyword is used to specify the last optional argument, but leaving the \fkeyw{flavor} parameter undefined.

%---------------------------------------------------------------------
\subsection{Procedure arguments}
%---------------------------------------------------------------------

An efficient feature that exists in many other languages is the ability to pass subroutines as arguments to subroutines. This can provide efficient ways to provide algorithms with user provided functions to be used within the algorithm. As an example, a function can be input to a numeric differentiation algorithm as a subroutine parameter. It is now possible to do this in Fortran 2003. 

To implement a subroutine that takes a function as an input parameter, the function definition has to be declared in the subroutine parameter declaration using an \fkeyw{interface} block.

\begin{lstlisting}
real(8) function integrate(a, b, func)

	real(8) :: a, b
	
	interface 
		real(8) function func(x)
			real(8), intent(in) :: x
		end function func
	end interface
	
	...
\end{lstlisting}

The routine can then be called by providing a function with the same interface as input to the function:

\begin{lstlisting}
real(8) function myfunc(x)
	
	real(8) :: x
	
	myfunc = sin(x)**2
	
end function myfunc
\end{lstlisting}

Calling the \fkeyw{integrate} function then becomes:

\begin{lstlisting}
area = integrate(0.0, 1.0, myfunc)
\end{lstlisting}

\lstinputlisting{source/procedures_as_arguments/utils.f90}
\lstinputlisting{source/procedures_as_arguments/main.f90}


%---------------------------------------------------------------------
\subsection{Modules}
%---------------------------------------------------------------------

When programs become larger, they often need to be split into more manageable parts. In other languages this is often achieved using include files or packages. In Fortran 77, no such functionality exists. Source files can be grouped in files, but no standard way of including specific libraries of subroutines or function exists in the language. The C preprocessor is often used to include code from libraries in Fortran, but is not standardised in the language itself. 

In Fortran 90 the concept of modules was introduced. A Fortran 90 module can contain both variables, parameters and subroutines. This makes it possible to divide programs into well defined modules which are more easily maintained. The syntax for a module is similar to that of how a main program in Fortran is defined.

\begin{fsyntax}
\textbf{module} module-name \\
\ftab [specification-stmts] \\
\protect{[}\textbf{contains} \\
\ftab module-subprograms] \\
\textbf{end module} [module-name]]
\end{fsyntax}

The block \fexpr{specification-stmts} defines the variables that are available for programs or subroutines using the module. In the block, \fexpr{module\--sub\-programs}, subroutines in the module are declared. A module can contain only variables or only subroutines or both. One use of this, is to declare variables common to several modules i a separate module. Modules are also a good way to divide a program into logical and coherent parts. Variables and functions in a module can be made private to a module, hiding them for routines using the module. The keywords \fkeyw{public} and \fkeyw{private} can be used to control the access to a variable or a function. In the following code the variable, \fvar{a}, is hidden from subroutines or programs using this module. The variable, \fvar{b}, is however visible. When nothing is specified in the variable declaration, the variable is assumed to be public.

\begin{lstlisting}
module mymodule

    integer, private :: a
    integer :: b
    ...

\end{lstlisting}

The ability to hide variables in modules enables the developer to hide the implementation details of a module, reducing the risk of accidental modification variables and use of subroutines used in the implementation.

To access the routines and variables in a module the \fkeyw{use} statement is used. This makes all the public variables and subroutines available in programs and other modules. In the following example illustrate how the subroutines use in the previous examples are placed in a module, \fname{truss}, and used from a main program. 

\lstinputlisting[texcl]{source/modules/module_truss.f90}

Main program using the \fname{truss} module.

\lstinputlisting[texcl]{source/modules/module_main.f90}

Please note that the declaration of \fvar{ap} in the \fname{truss} module is used to define the precision of the variables in the main program.

%---------------------------------------------------------------------
\subsection{Public and private attributes}
%---------------------------------------------------------------------

When implementing modules, some of the routines and variables are only used the implementation of the module. That is, some of the variables and subroutines should not be accessible for the user of the module. To control access to variables and subroutines the attributes \fkeyw{private} and \fkeyw{public} can be used in the declaration of variables and subroutines. A variable can be declared private by adding the keyword \fkeyw{private} to the attribute list in the declaration as shown in the following example:

\begin{lstlisting}
real, private :: a
\end{lstlisting}

If no \fkeyw{private} attribute is given the variable is by default declared as \fkeyw{public}. If a private variable is access from another module a main program will generate a compiler error. 

To declare a subroutine or function as private it has to be declared as such in the specification part of the module, that is before the \fkeyw{contains}-keyword. In the following example illustrates the concept.

\begin{lstlisting}
module mymodule

	private myprivatesub
	
contains

	subroutine myprivatesub
	
		print *, 'This subroutine can only be called from within the module.'
	
	end subroutine myprivatesub
	
	subroutine mypublicsub
	
		print *, 'This subroutine can be called from other modules.'
	
	end subroutine mypublicsub
	
end module mymodule
\end{lstlisting}

In this example, \fname{myprivatesub}, can only be called from within the module. Calling it from another module or main program will result in a compiler error. \fname{myprivatesub} is not declared as private in the specification part and hence can be called from all other modules. 

%---------------------------------------------------------------------
\subsection{Overloading}
%---------------------------------------------------------------------

As Fortran is a strongly typed language, supporting multiple data types in a single subroutine is not possible and requires separate unique subroutines declarations. To simplify module use and enable a module user to call a routine with different data types, Fortran 90 supports the concept of overloading. Using overloading the compiler can decide which routine to call depending on the datatype used. However, this requires a special declaration in the module specification. 

To illustrate this, a function, \fname{func}, is implemented that can take either a floating point parameter or an integer parameter. To implement this function, an interface declaration for \fname{func} is added in the module specification part:

\begin{lstlisting}
module overloaded

	interface func
		module procedure ifunc, rfunc
	end interface
	...
\end{lstlisting}

This tells the compiler to map the \fname{func}-function to the functions \fname{ifunc} or \fname{rfunc}, depending on the datatype used when the function is called. \fname{ifunc} or \fname{rfunc} are implemented as normal functions as shown below:

\begin{lstlisting}
	...
	
contains

integer function ifunc(x)
	
	integer, intent(in) :: x
	ifunc = x * 42
	
end function ifunc

real(8) function rfunc(x)
	
	real(8), intent(in) :: x
	rfunc = x / 42.0_8
	
end function rfunc

end module overloaded
\end{lstlisting}

The \fname{func}-function can now be called using either floating point values or integer values illustrated below in the following example:

\begin{lstlisting}
program overloading

	use special
	
	integer :: a = 42
	real(8) :: b = 42.0_8
	
	a = func(a)
	b = func(b)
	
	print *, a
	print *, b 
	
end program overloading
\end{lstlisting}

Running this program produce the following output:

\cmdmode

\begin{lstlisting}
$ ./overloading 
        1764
   1.0000000000000000
\end{lstlisting}%$

\fmode

This means that \fname{ifunc} is called in the first call to \fname{func} and \fname{rfunc} is called in the second call to \fname{func}.

%---------------------------------------------------------------------
\subsection{operator overloading}
%---------------------------------------------------------------------

In many modern languages such as C++ and Python, the operators can be overloaded to support expressions for user implemented data types. This is also possible in Fortran. To illustrate how this is achieved, a \fname{vector\_operations}-module is implemented, enabling addition of vectors using the + operator. 

First, a vector type is defined in our module \fname{vector\_operations}. This is the actual data type that will be used in the expressions to be evaluated.

\begin{lstlisting}
module vector_operations

	type vector
		real(8) :: components(3)
	end type vector
	...
\end{lstlisting}

Next, an interface for overloading the + operator is defined. The interface tells the compiler which function to call when it encounters an expression with our vector data type. In this example the \fname{vector\_plus\_vector}-function will be called for the + operator.

\begin{lstlisting}
	...
	interface operator(+)
		module procedure vector_plus_vector
	end interface
	...
\end{lstlisting}

In the final step the actual function for adding vectors is implemented. This functions needs to have two input parameters for the vectors to be added in the operation. It also needs to return a \fname{vector} data type.

\begin{lstlisting}
...
contains

type(vector) function vector_plus_vector(v1, v2)

	type(vector), intent(in) :: v1, v2
	vector_plus_vector%components = v1%components + v2%components
	
end function vector_plus_vector

end module vector_operations
\end{lstlisting}

The new data type together with the defined + operator can now be used to implement compact expressions for vector algebra as illustrated in the following code:

\begin{lstlisting}
program operator_overloading

	use vector_operations

	type(vector) :: v1
	type(vector) :: v2
	type(vector) :: v
	
	v1%components = (/1.0, 0.0, 0.0/)
	v2%components = (/0.0, 1.0, 0.0/)
	
	v = v1 + v2
	
	print *, v

end program operator_overloading
\end{lstlisting}

Running the code will produced the expected output:

\cmdmode

\begin{lstlisting}
$ ./opoverload 
   1.0000000000000000        1.0000000000000000        0.0000000000000000    
\end{lstlisting}%$

\fmode

Operators for -, * and / can be implemented using the same technique.

%---------------------------------------------------------------------
\subsection{Allocatable dummy arguments}
%---------------------------------------------------------------------

\lstinputlisting{source/allocatable_dummy/main.f90}

%---------------------------------------------------------------------
\subsection{Allocatable functions}
%---------------------------------------------------------------------

\lstinputlisting{source/allocatable_function/main.f90}

%---------------------------------------------------------------------
%\subsection{Submodules (2003)}
%---------------------------------------------------------------------

%\lstinputlisting{source/submodules/points.f90}
%\lstinputlisting{source/submodules/points_a.f90}
%\lstinputlisting{source/submodules/main.f90}

%---------------------------------------------------------------------
\section{Input and output}
%---------------------------------------------------------------------

Input and output to and from different devices, such as screen, keyboard and files are accomplished using the commands \fkeyw{read} and \fkeyw{write}. The syntax for these commands are:

\begin{fsyntax}
read(u, fmt) [list]\\
write(u, fmt) [list]
\end{fsyntax}

\fexpr{u} is the device that is used for reading or writing. If a star (*) is used as a device, standard output and standard
input are used (screen, keyboard or pipes).

\fexpr{fmt} is a string describing how variables should be read or written. This is often important when writing results to text files, to make it more easily readable. If a star (*) is used a so called free format is used, no special formatting is used. The format string consists of one or more format specifiers, which have the general form:

\begin{fsyntax}
[repeat-count] format-descriptor w[.m]
\end{fsyntax}

where \fexpr{repeat-count} is the number of variables that this format applies to. \fexpr{format-descriptor} defines the type of format specifier. \fexpr{w} defined the width of the output field and \textit{m} is the number of significant numbers or decimals in the output. The following example outputs some numbers using different format specifiers and table~\ref{table:formatkoder} show the most commonly used format specifiers.

\lstinputlisting[texcl]{source/formatting/formatting.f90}

The program produces the following output:

\begin{lstlisting}
123456789012345
      5.676
     0.6758E-01
     0.6758E+00
         0.6758
  0.675779000000000
            156
         156
\end{lstlisting}

\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
Kod & Beskrivning \\
\hline
E   & Scientific notation. Values are converted to the format "-d.dddE+ddd". \\
F   & Decimal notation. Values are converted to the format "-d ddd.ddd...". \\
G   & Generic notation. Values are converted to the format -ddd.ddd or -d.dddE+ddd \\
I   & Integers. \\
A   & Strings \\
TRn & Move $n$ positions right \\
Tn  & Continue at position $n$ \\
\hline
\end{tabular}
\end{center}
\caption{Formatting codes in \fkeyw{read}/\fkeyw{write}}
\label{table:formatkoder}
\end{table}

During output a invisible cursor is moved from left to right. The format specifiers TR$n$ and T$n$ are used to move this cursor. TR$n$ moves the cursor $n$ positions to the right from the previous position. T$n$ places the cursor at position $n$. Figure~\ref{fig:format_positiong} shows how this can be used in a write-statement.

\fignormal{kompendiumv4Fig1} {Positioning of output in Fortran
90/95} {fig:format_positioning}

The output routines in Fortran was originally intended to be used on row printers where the first character was a control character. The effect of this is that the default behavior of these routines is that output always starts at the second position. On modern computers this is not an issue, and the first character can be used for printing. To print from the first character, the format specifier \fkeyw{T1} can be used to position the cursor at the first position. The following code writes ''Hej hopp!'' starting from the first position.

\begin{lstlisting}
write(*,'(T1,A)') 'Hej hopp!'
\end{lstlisting}

A more thorough description of the available format specifiers in Fortran is given in Metcalf and Reid~\cite{metcalf00}.

%---------------------------------------------------------------------
\subsection{Reading and Writing from files}
%---------------------------------------------------------------------

The input and output routines can also be used to write data to and from files. This is accomplished by associating a file in the file system with a file unit number, and using this number in the \fkeyw{read} and \fkeyw{write} statements to direct the input and output to the correct files. A file is associated, opened, with a unit number using an \fkeyw{open}-statement. When operations on the file is finished it is closed using the
\fkeyw{close}-statement. 

The file unit number is an integer usually between 1 and 99. On many systems the file unit number 5 is the keyboard and unit 6 the screen display. It is therefore recommended to avoid using these numbers in file operations.

In the \fkeyw{open}-statement the properties of the opened files are given, such as if the file already exists, how the file is accessed (reading or writing) and the filename used in the filesystem.

An example of reading and writing file is given in the following example.

\lstinputlisting[texcl]{source/sample2/sample2.f90}

In this example, 2 files are opened, \ffname{indata.dat} and \ffname{utdata.dat} with \fkeyw{open}-statements. Using the \fkeyw{read}-statement five rows with 3 numbers on each row are read from the file \ffname{indata.dat}. The sum of each row is calculated and is written using \fkeyw{write}-statements to the file \ffname{utdata.dat}. Finally the files are closed using the \fkeyw{close}-statements.

%---------------------------------------------------------------------
\subsection{Dynamic format codes}
%---------------------------------------------------------------------

One problem that arises when writing formatted output, is how to handle output of data in which the number of columns is unknown at compile time. To solve this, a special technique using strings as file units can be employed. To illustrate this technique we implement a subroutine \fname{writeArray}, which takes an array of any size as input and tries to print it nicely. First we declare the module subroutine and extract the size of the incoming array:

\begin{lstlisting}
subroutine writeArray(A)
		
	real(8), dimension(:,:) :: A
	integer :: rows, cols, i, j
	character(255) :: fmt
		
	rows = size(A,1)
	cols = size(A,2)

	...
\end{lstlisting}

Next, we use a \fname{write}-statement, that instead of a file unit number takes the string, \fname{fmt}, and uses it as an output file. In the \fname{write}-statement, we write out the needed format code for printing the incoming array, which is then stored in the string \fname{fmt}.

\begin{lstlisting}
	...
	write(fmt, '(A,I1,A)') '(',cols, 'G8.3)'  
	...
\end{lstlisting}

The generated format code can now be used when printing the incoming array \fvar{A}.

\begin{lstlisting}
	...
	do i=1,rows
		print fmt, (A(i,j), j=1,cols)
	end do
		
	return
	
end subroutine writeArray
\end{lstlisting}

In the following main program, the implemented \fname{writeArray} subroutine is used to print a 6 by 6 matrix.

\begin{lstlisting}
program dynamic_fcodes

	use array_utils

	real(8) :: A(6,6)
	
	A = 42.0_8
	
	call writeArray(A)
	
end program dynamic_fcodes
\end{lstlisting}

The resulting formatted output is shown below:

\cmdmode

\begin{lstlisting}
$ ./dynamic_fcodes 
42.0    42.0    42.0    42.0    42.0    42.0    
42.0    42.0    42.0    42.0    42.0    42.0    
42.0    42.0    42.0    42.0    42.0    42.0    
42.0    42.0    42.0    42.0    42.0    42.0    
42.0    42.0    42.0    42.0    42.0    42.0    
42.0    42.0    42.0    42.0    42.0    42.0    
\end{lstlisting}%$

\fmode

%---------------------------------------------------------------------
\subsection{Namelist I/O}
%---------------------------------------------------------------------

The standard way of writing or reading text files in Fortran is using list directed I/O. This means specifying a list of variables to be read or written using the \fkeyw{read}- and \fkeyw{write}-statements. Fortran will automatically handle the conversion of datatypes to and from a text based format. A more flexible way of handling text file I/O is using namelists. Namelists can be considered as named list of variables to be used for reading or writing. In this scheme, variables can be read and written to files using names. To write variables and data using this technique, variables must be listed using the special \fkeyw{namelist} statement as shown below:

\begin{lstlisting}
integer :: no_of_eggs, litres_of_milk, kilos_of_butter, list(5)
namelist /food/ no_of_eggs, litres_of_milk, kilos_of_butter, list
\end{lstlisting}

Here a namelist, \fkeyw{food}, is defined consisting of the specified variables. Variables in a namelist can be of any type. To write the variables to a file, the \fkeyw{nml}-keyword can be used in the \fkeyw{read}- and \fkeyw{write}-statements to specify which namelist that should be used. 

The namelist in the text file starts with the \& character followed by the namelist-name then the namelist variable pairs are listed separated by commas. The namelist is ended with a single /. The following example shows 2 namelist entries in a text file:

\begin{lstlisting}
&food litres_of_milk=5, no_of_eggs=12, kilos_of_butter=42, list=1,2,3,4,5 /
&food litres_of_milk=6, no_of_eggs=24, kilos_of_butter=84, list=2,3,4,5,6 /
\end{lstlisting}

Multiple namelist entries can be read from an opened file. The following code shows how 2 namelist entries of the type \fvar{food} are read from an opened file:

\begin{lstlisting}
open(unit=ir, file='food.txt', status='old')
read(ir, nml=food)
print *, no_of_eggs, litres_of_milk, kilos_of_butter
read(ir, nml=food)
print *, no_of_eggs, litres_of_milk, kilos_of_butter
close(unit=ir)
\end{lstlisting}

Running this code produces the following output:

\cmdmode

\begin{lstlisting}
          12           5          42
          24           6          84
\end{lstlisting}

\fmode

Writing using namelist I/O is done in the same way as reading. The following code shows how the same namelist variables are written to a namelist:

\begin{lstlisting}
open(unit=iw, file='food2.txt', status='new')
write(iw, nml=food)
close(unit=iw)
\end{lstlisting}

The contents of the written file, \fname{food2.txt}, is shown below:

\cmdmode

\begin{lstlisting}
&FOOD
 NO_OF_EGGS=         24,
 LITRES_OF_MILK=          6,
 KILOS_OF_BUTTER=         84,
 LIST=          2,          3,          4,          5,          6,
 
 /
\end{lstlisting}

Pleas notice that Fortran allways uses uppercase for variable names in the written file.

%\lstinputlisting{source/namelist_io/main.f90}

%---------------------------------------------------------------------
\subsection{Unformatted I/O}
%---------------------------------------------------------------------

In the previous sections data was read and written in human readable text format. For larger data structures this can be very inefficient. To solve this Fortran can also write data in its native binary format directly to disk. This can save space and can also be read and written much faster to disk. However, the binary format is not standardised and differs between different hardware platforms, preventing files to be used on different hardware. 

Reading and writing binary data is done using the same \fkeyw{read}- and wr\fkeyw{write}-ite statements as before, but without the formatting options. Writing an array to disk in binary form can be done with just one simple statement:

\fmode

\begin{lstlisting}
real :: A(100)
...
write(iw) A
\end{lstlisting}

Reading the same array back from disk is just as easy, using the \fkeyw{read}-statement.

\begin{lstlisting}
real :: A(100)
...
read(ir) A
\end{lstlisting}

It is also possible to write several variables to disk using multiple \fkeyw{write}- statements.

\begin{lstlisting}
real :: A(100), B(200)
...
write(iw) A
write(iw) B
\end{lstlisting}

However, it is important to note that data has to be read back in the same order it is was written. So the code for reading the data back becomes:

\begin{lstlisting}
real :: A(100), B(200)
...
read(ir) A
read(ir) B
\end{lstlisting}

To enable reading and writing unformatted I/O files (binary files) the keyword \fvar{form='unformatted'} must be added to the \fkeyw{open}-statement. 

\begin{lstlisting}
real :: A(100), B(200)
...
open(unit=ir, file='arrays.dat', form='unformatted')
read(ir) A
read(ir) B
close(ir)
\end{lstlisting}

The concept of unformatted I/O is illustrated in a larger example. In this example an array of the derived datatype \fvar{particle} is created, initialised and then saved to disk as unformatted I/O. After saving the data to disk it is read back using unformatted I/O and printed on standard output. The listing is shown below:

\lstinputlisting{source/unformatted_io/main2.f90}

The code produced the following output when run:

\cmdmode

\begin{lstlisting}
$ ./unformatted_io_2
   0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       1.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       1.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       1.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       1.00000000       0.00000000       0.00000000       0.00000000       0.00000000 ....
\end{lstlisting}%$

Which means that the data was read correctly back from disk. 

%---------------------------------------------------------------------
\subsection{Direct access files}
%---------------------------------------------------------------------

A variant of unformatted I/O is direct access files. One problem with unformatted I/O is that files have to be read and written sequentially. This make it inefficient if you would like to access certain parts of the file randomly. To solve this problem Fortran provides direct access file format. In this format the file is divided in several equally spaced data records. These records can be read randomly back from a single file. It can be compared to a datbase file with data records. 

To create a direct access file consisting of records of the following derived data type,

\fmode

\begin{lstlisting}
type account
    character(len=40) :: account_holder
	real :: balance
end type account
\end{lstlisting}

the size of the data record has to be calculated. This can be done using the \fkeyw{inquire}-function. This assigns a variable the record size of the data type, which is shown in the following listing:

\begin{lstlisting}
type(account) :: account
integer :: recordSize
...	
inquire(iolength=recordSize) account
\end{lstlisting}

The \fvar{recordSize} variable can now be used when we create a direct access file using the \fkeyw{open}-statement:

\begin{lstlisting}
open(unit=iw, file='accounts.dat', access='direct', recl=recordSize, status='replace')
\end{lstlisting}

Writing the records is accomplished using the normal \fkeyw{write}-statement with an added \fkeyw{rec}-option for the record position to be written.

\begin{lstlisting}
write(iw, rec=1) account
\end{lstlisting}

It is possible to write to any record position when writing record. Reading record is done using the \fkeyw{read}-statements using the \fkeyw{rec}-option.

When reading or writing to direct access files there is an invisible cursor or pointer pointing to the current record. It is possible to manipulate this cursor using the \fkeyw{rewind}- and \fkeyw{backspace}-statements. The \fkeyw{rewind}-statement moves the pointer to the first record in the file. the \fkeyw{backspace}-statement moves the pointer one record back in the file, these operations are illustrated in figure~\ref{fig:io_rewind_backspace}.

\fignormal{io_rewind_backspace}{\fkeyw{rewind}- and \fkeyw{backspace}-statements}{fig:io_rewind_backspace}

It is also possible to truncate a direct access file at a given position using the \fkeyw{endfile}-statement, as illustrated in figure~\ref{fig:io_endfile}. All records after the current record will be truncated.

\figsmall{io_endfile}{Truncating a file using the \fkeyw{endfile}-statement}{fig:io_endfile}

The following code shows a complete example, writing to records to a direct access file:

\lstinputlisting{source/unformatted_io/main.f90}

%---------------------------------------------------------------------
\subsection{Error handling in I/O operations}
%---------------------------------------------------------------------

One problem with reading and writing files is that errors can occur on a system level, such as unavailable disk space, file system problems and non-existant files. If not handled, the program will crash in an unexpected way and prevent proper clean up code to be run. In Fortran I/O errors are handled using the \fkeyw{err}-option in all I/O related functions. Using the \fkeyw{err}-option a label can be defined where the execution continues when an I/O error occurs. 

In the following code a file is opened for reading. Error handling code is added for each I/O operation, providing a different label and response for all error conditions. 

\lstinputlisting{source/error_handling/main.f90}

Figure~\ref{fig:error_handling} shows the flow of the program.

\figsmall{error_handling}{Error handling i Fortran I/O operations}{fig:error_handling}

\newpage
It is also possible to determine the reason for ther error by using the \fkeyw{iostat} option. A variable is associated with the the \fkeyw{iostat}-option and when an error occurs the variable will be assigned an with an error code. The following code shows an example of how this option can be used:

\begin{lstlisting}
integer :: ierr
...
open(..., iostat=ierr)
...
read(unit=xx, iostat=ierr)
...
close(unit=xx, iostat=ierr)
\end{lstlisting}

If no error was encountered the associated variable with be assigned an error code of 0. Other codes can be:

\begin{itemize}
\item -2, End of record condition occurs in non-advancing I/O.
\item -1, End of file condition. 
\item >1, Standardised list of fortran error codes.
\end{itemize}


When the \fkeyw{iostat}-option is used all default error messages will be suppressed and code execution will continue. The best use of this option is combined with the \fkeyw{err}-option to provide clear error messages to users as show in the following code example:

\begin{lstlisting}
subroutine read_from_file(...)
    ...
    integer :: ierr
    ...
    read(unit=xx, err=101, iostat=ierr)
    ...
    return

101 print*, 'Error ', ierr, ' reading file.' 
    return
    
end subroutine
\end{lstlisting}

%---------------------------------------------------------------------
\section{String manipulation}
%---------------------------------------------------------------------

There are several ways of manipulating strings in Fortran. Strings can be concatenated with the operator, \foper{//}, as shown in the following example:

\begin{lstlisting}
c1 = 'Hej '
c2 = 'hopp!'
c = c1 // c2 ! = 'Hej hopp!'
\end{lstlisting}

Fortran does not have dynamic strings, so the size of the resulting string must be large enough for the concatenated string.

Substrings can be extracted using a syntax similar to the syntax used when indexing arrays.

\begin{lstlisting}
c3 = c(5:8) ! Contains the string 'hopp'
\end{lstlisting}

A common task in many codes is the conversion of numbers to and from strings. Fortran does not have any explicit functions these type of conversions, instead the the \fkeyw{read} and \fkeyw{write} statements can be used together with strings to accomplish the same thing. By replacing the file unit number with a character string variable, the string can be read from and written to using \fkeyw{read} and \fkeyw{write} statements.

To convert a floating point value to a string the following code can be used.

\begin{lstlisting}
character(255) :: mystring
real(8) :: myvalue
value = 42.0
write(mystring,'(G15.4)') value
! mystring now contains '      5.676'
\end{lstlisting}

To convert a value contained in string to a floating point value the read-statement is used.

\begin{lstlisting}
character(255) :: mystring
real(8) :: myvalue
mystring = '42.0'
read(mystring,*) myvalue
! myvalue now contains 42.0
\end{lstlisting}

A more complete example is shown in the following listing:

\lstinputlisting{source/strings/strings2.f90}

The program produces the following output.

\begin{lstlisting}
5
42
\end{lstlisting}

%---------------------------------------------------------------------
\section{Array features}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\subsection{Forall- and Where-statements}
%---------------------------------------------------------------------

Fortran has added a number of new loop-statements. The \fkeyw{forall}-statement has been added to optimise nested loops for execution on multiprocessor machines. The syntax is:

\begin{fsyntax}
\textbf{forall} (index = lower:upper [,index = lower:upper])\\
\ftab [body]\\
\textbf{end forall}
\end{fsyntax}

The following example shows how a \fkeyw{do}-statement can be replaced with a \fkeyw{forall}-statement.

\begin{lstlisting}[texcl,escapechar=\%]
do i=1,n
    do j=1,m
        A(i,j)=i+j
    end do
end do

! Is equivalent with

forall(i=1:n, j=1:m)
    A(i,j)=i+j
end forall
\end{lstlisting}

Another statement optimised for multiprocessor architectures is the \fkeyw{where}-statement. With this statement conditional operations on an array can be achieved efficiently. The syntax comes in two versions.

\begin{fsyntax}
\textbf{where} (logical-array-expr)\\
\ftab array-assignments\\
\textbf{end where}
\end{fsyntax}

and

\begin{fsyntax}
\textbf{where} (logical-array-expr)\\
\ftab array-assignments\\
\textbf{else where}\\
\ftab array-assignments\\
\textbf{end where}
\end{fsyntax}

The usage of the \fkeyw{where}-statement is best illustrated with an example.

\begin{lstlisting}
where (A>1)
    B = 0
else where
    B = A
end where
\end{lstlisting}

In this example two arrays with the same size are used in the \fkeyw{where}-statement. In this case the values in the \fvar{B} array are assigned 0 when an element in the A array is larger than 1 otherwise the element in \fvar{B} is assigned the same value as in the \fvar{A} array.

%---------------------------------------------------------------------
%\subsection{Pure procedures}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\subsection{Elemental procedures}
%---------------------------------------------------------------------


%---------------------------------------------------------------------
\section{Pointers}
%---------------------------------------------------------------------

\lstinputlisting{source/pointers/main.f90}

%---------------------------------------------------------------------
\section{System functions}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\subsection{C Interoperability}
%---------------------------------------------------------------------

\lstinputlisting{source/c_interop/main.f90}

%---------------------------------------------------------------------
\subsection{Access to computing environment}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\section{Object-oriented programming}
%---------------------------------------------------------------------

In procedural programming, data and subroutines are treated separately. Subroutines operate on provided data structures and variables. In object-oriented programming data and subroutines are combined into objects. Objects in numerical computing can be  be different matrix types, particles, vectors or solvers. The major benefits are that the actual data structures used in the implementation of an object can be hidden from the user of the object, enabling the developer of an object to improve the implementation without affecting users of the objects (encapsulation). Another important feature of object-oriented programming is the ability to inherit and extend functionality of objects (inheritance). This enables user of object and developers to extend and modify functionality of existing objects, relying on functionality of the parent object. 

In Fortran 2003 object-oriented features where added to the language, making Fortran almost as feature rich as other more recent languages. Most modern Fortran compilers today support the object-oriented features added in the 2003 standard, enabling developers to implement truly object-oriented numerical applications in Fortran.

The functionality and data structures of objects are defined in classes in most programming object-oriented languages. Classes can be seen as templates for objects. When an object is to be created the class is used as the template for the new object. Created objects are also called instances of a class.

In Fortran the object-oriented features are implemented by extending the derived datatype concepts of fortran 90. A derived datatype now has a \fkeyw{contains}-section in which the procedures of the objects are specified. Derived datatypes are now also by definition objects or instances of the derived type.

To illustrate the concepts, a simple particle object is defined as an object in Fortran. The particle object is defined as a derived data type in a module, particles. To eliminate any name clashes when creating new objects of this type, the derived type is given the name, \fvar{particle\_class}. This is also fits the object-oriented model of derived type being equivalent to classes. The initial class definition then becomes:

\begin{lstlisting}
module particles

    implicit none

    type particle_class
        real :: pos(3)
        real :: vel(3)
    end type particle_class

end module particles
\end{lstlisting}

The definition currently corresponds exactly to a derived data type in Fortran and can be used as such as well. To create instance of the \fvar{particle\_class} is equivalent to creating a variable of a specified derived data type:

\begin{lstlisting}
use particles
...
type(particle_class) :: particle
\end{lstlisting}

To access the variables of the instance the \fkeyw{\%} operator is used. In the following examplen the \fvar{pos}-variable is assigned the coordinate $(0,0,0)$.

\begin{lstlisting}
particle % pos = (/ 0.0, 0.0, 0.0 /)
\end{lstlisting}

However, accessing the instance variables goes against the principles of object-oriented programming, where one of the more important aspects is data encapsulation and hiding the internal workings of the objects. How do we use the new Fortran features to prevent the need to access the data structures directly? The first aspect to cover is initialisation of the instance  variables. To do this, a method, \fname{init}, will be added to our class. First, a \fkeyw{contains}-section with a procedure specification for the \fname{init} subroutine. As it is not allowed to have duplicate subroutine names in a module we assign an actual implementation subroutine using the => operator. Please note that no parameters lists are specified in this declaration. Secondly, to distinguish the member variables from other variables in the class implementation, as well as preventing name collisions with the names of the access methods, the member variables are prefixed with \fname{m\_}. The complete class then becomes:

\begin{lstlisting}
module particles

    implicit none

    type particle_class
        real :: m_pos(3)
        real :: m_vel(3)
    contains
        procedure :: init => particle_init
    end type particle_class
    ...
\end{lstlisting}

This declaration states that the class, \fkeyw{particle\_class}, has a member subroutine with the name, \fname{init}, defined later in the source code by the subroutine \fname{particle\_init}. To complete the class definition, the subroutine \fname{particle\_init} have to be added to the \fname{particles} module. 

All member subroutines can take a first dummy argument with containing a reference to the actual instance. This will be used to enable us to do our initialisation on the actual data structures of the instance. The \fname{init}-subroutine of our particle class then becomes:

\begin{lstlisting}
module particles

...

contains

subroutine particle_init(this)

    class(particle_class) :: this

    this % m_pos = (/0.0, 0.0, 0.0/)
    this % m_vel = (/0.0, 0.0, 0.0/)

end subroutine particle_init

end module particles
\end{lstlisting}

In the previous example the \fname{particle\_init}-subroutine has a dummy variable, \fvar{this}, which is used to access the actual instance variables of the class. This variable is automatically passed to the routine by the compiler. It is now possible to initialise our newly created instance without accessing the member variables directly. The code to create a new object and initialise it data structure then becomes:

\begin{lstlisting}
type(particle_class) :: particle

call particle % init
\end{lstlisting}

The dummy argument, \fname{init}, can be left out of the call to \fname{init}. The same concept of passing the instance variable as a argument in the class definition can also be found in Python, where a special variable, \fkeyw{self} is used in the member subroutines. Please also note that we call the method with the \fname{init} and not the actual implemented subroutine, \fname{particle\_init}. This enables us to have the same class interface in several classes.

%---------------------------------------------------------------------
\subsection{Access methods}
%---------------------------------------------------------------------

The class now has the ability to initialise its data variables. However, we don't have any ways of accessing the variables without accessing them directly. To solve this we have to add special methods for accessing internal class variables. First, methods for assigning the position and velocity of the particle is added in the class declaration:

\begin{lstlisting}
    ...
    type particle_class
        real :: m_pos(3)
        real :: m_vel(3)
    contains
        procedure :: init => particle_init
        procedure :: set_position => particle_set_position <*\hladded*>
        procedure :: set_velocity => particle_set_velocity <*\hladded*>
    end type particle_class
    ...
\end{lstlisting}

When this has been done the implementations of these subroutines are added in the \fkeyw{contains}-section of the \fname{parcticles}-modules:
    
\begin{lstlisting}
contains

...

subroutine particle_set_position(this, x, y ,z)

    class(particle_class) :: this
    real :: x, y, z

    this % m_pos = (/x, y, z/)

end subroutine particle_set_position

subroutine particle_set_velocity(this, vx, vy ,vz)

    class(particle_class) :: this
    real :: vx, vy, vz

    this % m_vel = (/vx, vy, vz/)

end subroutine particle_set_velocity

end module particles        
\end{lstlisting}

In the same way as in the \fname{init}-subroutine, \fname{this}, is used to access the member variables of the class instance. 

It is now possible to assign values to our instances without directly accessing the internal member variables as shown in the following code:

\begin{lstlisting}
call particle % set_position(1.0, 1.0, 1.0)
call particle % set_velocity(1.0, 1.0, 1.0)
\end{lstlisting}

To retrieve values from the instance, 2 additional subroutines are needed, \fname{get\_position} and \fname{get\_velocity} are added to the class definition and implementation.

\begin{lstlisting}
module particles

    implicit none

    type particle_class
        real :: m_pos(3)
        real :: m_vel(3)
    contains
        procedure :: init
        procedure :: set_position => particle_set_position
        procedure :: set_velocity => particle_set_velocity
        procedure :: get_position => particle_get_position <*\hladded*>
        procedure :: get_velocity => particle_get_velocity <*\hladded*>
    end type particle_class

contains

...

subroutine particle_get_position(this, x, y ,z)

    class(particle_class) :: this
    real, intent(out) :: x, y, z

    x = this % m_pos(1)
    y = this % m_pos(2)
    z = this % m_pos(3)

end subroutine particle_get_position

subroutine particle_get_velocity(this, vx, vy ,vz)

    class(particle_class) :: this
    real, intent(out) :: vx, vy, vz

    vx = this % m_vel(1)
    vy = this % m_vel(2)
    vz = this % m_vel(3)

end subroutine particle_get_velocity

...
\end{lstlisting}

It is now possible to access the instance variables using these subroutines as shown in the following example:

\begin{lstlisting}
real :: x, y, z
...
call particle % get_position(x, y, z)
\end{lstlisting}

It is also possible to use functions to access the instance variables, as shown in the following code:

\begin{lstlisting}
real :: x, y, z
...
x = particle % x()
\end{lstlisting}

\fname{x()} is a Fortran function member of \fname{particle\_class}.

%---------------------------------------------------------------------
\subsection{Pretty printing}
%---------------------------------------------------------------------

Other functionalities that could be integrated into the class is the ability to pretty print its state variables. Consider the following subroutine:

\begin{lstlisting}
subroutine particle_print(this)

    class(particle_class) :: this

    print*, 'Particle position'
    print*, '-----------------'
    write(*, '(3G10.3)') this % m_pos(1), this % m_pos(2), this % m_pos(3)

    print*, ''

    print*, 'Particle velocity'
    print*, '-----------------'
    write(*, '(3G10.3)') this % m_vel(1), this % m_vel(2), this % m_vel(3)

end subroutine particle_print
\end{lstlisting}

This subroutine will enable a user of the class to easily print the instance variables in a nice formatted way without actually accessing the instance variables:

\begin{lstlisting}
call particle % print
\end{lstlisting}

This code would give the following output:

\cmdmode

\begin{lstlisting}
 Particle position
 -----------------
  1.00      1.00      1.00    
 
 Particle velocity
 -----------------
  1.00      1.00      1.00    
\end{lstlisting}

An extension of this could be to provide subroutines for reading and writing the object instance to a file.

%---------------------------------------------------------------------
\subsection{Restricting access}
%---------------------------------------------------------------------

In the previous code examples the internal state variables where encapsulated using access methods. However, it is still possible for a user of the instance to access the member variable. This could let to users of the instance modifying the variables directly either willingly or by mistake, which could lead complicated bugs. To solve this Fortran enables the classes to mark these instance variable as private preventing access to them. Adding a \fkeyw{private}-directive in the class declaration hides these variables from the users of the instance, as shown in the following code:

\fmode

\begin{lstlisting}
type particle_class
private <*\hladded*>
    real :: m_pos(3)
    real :: m_vel(3)
contains
\end{lstlisting}

Assigning these variables as shown in the following example,

\begin{lstlisting}
particle % m_pos(1) = 0.0
\end{lstlisting}

will produce the following compilation error:

\cmdmode

\begin{lstlisting}
    particle % m_pos(1) = 0.0
                  1
Error: Component 'm_pos' at (1) is a PRIVATE component of 'particle_class'
\end{lstlisting}

\fmode

This means that using the \fkeyw{private} in class declaration effectively will prevent any users mistakenly accessing the private instance variables of any classes. 

The \fkeyw{private} before the variable declaration will make all variables private. It is also possible to selectively make variables public or private by removing the private declaration and adding the variable attribute \fkeyw{private} to the variable declaration as below:

\begin{lstlisting}
type particle_class
    real, private :: m_pos(3)
    real :: m_vel(3)
\end{lstlisting}

In this code \fname{m\_pos} is private and \fname{m\_vel} is public as all variables are public by default.

In a similar way it is possible to prevent access to member subroutines or functions using the \fkeyw{private}- or \fkeyw{public}-attributes on for each subroutine declaration as in the following example:

\begin{lstlisting}
type particle_class
private
    real :: m_pos(3)
    real :: m_vel(3)
contains
    procedure :: init => particle_init
    procedure :: set_position => particle_set_position
    procedure :: set_velocity => particle_set_velocity 
    procedure :: get_position => particle_get_position
    procedure :: get_velocity => particle_get_velocity
    procedure :: print => particle_print
    procedure, private :: setup => particle_setup <*\hladded*>
end type particle_class
\end{lstlisting}

Here a private method \fname{setup} has been added that can only be called for member subroutines of the \fname{particle}-class.

%---------------------------------------------------------------------
\subsection{Extending existing classes}
%---------------------------------------------------------------------

Classes in Fortran can be extended using the special attribute \fkeyw{extends} in its type definition. In the following example the previous \fname{particle\_class} is extended by the \fname{sphere\_particle\_class} to handle a spherical particle. 

\begin{lstlisting}
type, extends(particle_class) :: sphere_particle_class
private
    real :: m_radius
contains
    procedure :: set_radius => sphere_set_radius
    procedure :: get_radius => sphere_get_radius
end type sphere_particle_class
\end{lstlisting}

In the type definition a private member variable, \fname{m\_radius} and its access methods, \fname{set\_radius} and \fname{get\_radius} are added. The access methods are similar to the access method of the \fname{particle\_class}.

\begin{lstlisting}
subroutine sphere_set_radius(this, r)

    class(sphere_particle_class) :: this
    real :: r

    this % m_radius = r

end subroutine sphere_set_radius

real function sphere_get_radius(this)

    class(sphere_particle_class) :: this

    get_radius = this % m_radius

end function sphere_get_radius
\end{lstlisting}

The above type definition, will override the existing \fname{init}-routine from the \fname{particle\_class}. This means that the existing initialisation routine will not be called. To solve this, the \fname{sphere\_init}-routine needs to call the existing \fname{particle\_init}-routine from the extended class. The \fname{sphere\_init} initalisation routine is shown below:

\begin{lstlisting}
subroutine sphere_init(this)

    class(sphere_particle_class) :: this
    
    ! --- Calling inherited init routine.

    call this % particle_class % init() 

    this % m_radius = 1.0

end subroutine sphere_init
\end{lstlisting}

The format of a call to a inherited routine is:

\begin{fsyntax}
call [instance reference] \% [type definition name] \% [routine name]
\end{fsyntax}

%---------------------------------------------------------------------
\subsection{Overriding class methods}
%---------------------------------------------------------------------

In the previous chapter a first example of 






























